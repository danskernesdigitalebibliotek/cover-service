<?php

/**
 * @file
 */

namespace App\EventSubscriber;

use App\Entity\Image;
use App\Entity\Search;
use App\Event\IndexReadyEvent;
use Doctrine\DBAL\ConnectionException;
use Doctrine\ORM\EntityManagerInterface;
use Psr\Log\LoggerInterface;
use Symfony\Component\EventDispatcher\EventSubscriberInterface;

/**
 * Class VendorEventSubscriber.
 */
class IndexEventSubscriber implements EventSubscriberInterface
{
    private $em;
    private $statsLogger;

    public function __construct(EntityManagerInterface $entityManager, LoggerInterface $statsLogger)
    {
        $this->em = $entityManager;
        $this->statsLogger = $statsLogger;
    }

    /**
     * {@inheritdoc}
     */
    public static function getSubscribedEvents()
    {
        return [
            IndexReadyEvent::NAME => 'onIndexEvent',
        ];
    }

    /**
     * Updated event handler.
     *
     * @param IndexReadyEvent $event
     */
    public function onIndexEvent(IndexReadyEvent $event)
    {
        $material = $event->getMaterial();
        $image = $this->getImage($event->getImageId());
        $source = $image->getSource();

        $repos = $this->em->getRepository(Search::class);

        try {
            // There may exists a race condition when multiple queues are
            // running. To ensure we don't insert duplicates we need to
            // wrap our search/update/insert in a transaction.
            $this->em->getConnection()->beginTransaction();

            try {
                foreach ($material->getIdentifiers() as $identifier) {
                    // Check if the index already exist, if so update it
                    $search = $repos->findOneBy([
                        'isIdentifier' => $identifier->getId(),
                        'isType' => $identifier->getType(),
                    ]);

                    if (empty($search)) {
                        // It did not exists, so create new record.
                        $search = new Search();
                        $search->setIsType($identifier->getType())
                            ->setIsIdentifier($identifier->getId())
                            ->setImageUrl($image->getCoverStoreURL())
                            ->setImageFormat($image->getImageFormat())
                            ->setWidth($image->getWidth())
                            ->setHeight($image->getHeight())
                            ->setAutoGenerated($image->isAutoGenerated())
                            ->setSource($source);

                        $this->em->persist($search);
                    } else {
                        $sourceRank = $source->getVendor()->getRank();
                        $searchRank = $search->getSource()->getVendor()->getRank();

                        // Rank is unique so can never be identical for two different vendors
                        // but we need to update search if update image from same vendor.
                        if ($sourceRank <= $searchRank) {
                            $search->setImageUrl($image->getCoverStoreURL())
                                ->setImageFormat($image->getImageFormat())
                                ->setWidth($image->getWidth())
                                ->setHeight($image->getHeight())
                                ->setAutoGenerated($image->isAutoGenerated())
                                ->setSource($source);
                        }
                    }
                }

                // Make every thing stick.
                $this->em->flush();

                $this->em->getConnection()->commit();
            } catch (\Exception $exception) {
                $this->em->getConnection()->rollBack();

                $this->statsLogger->error('Database exception: '.get_class($exception), [
                    'service' => 'IndexEventSubscriber',
                    'message' => $exception->getMessage(),
                    'identifiers' => $material->getIdentifiers(),
                ]);
            }
        } catch (ConnectionException $exception) {
            $this->statsLogger->error('Database Connection Exception', [
                'service' => 'IndexEventSubscriber',
                'message' => $exception->getMessage(),
                'identifiers' => $material->getIdentifiers(),
            ]);
        }
    }

    /**
     * Find search data in the database.
     *
     * @param int $imageId
     *   Database ID for the image
     *
     * @return mixed
     *   Database object if found else empty
     */
    private function getImage(int $imageId)
    {
        // Check that cover store is ready.
        $repos = $this->em->getRepository(Image::class);
        $image = $repos->findOneById($imageId);

        return $image;
    }
}
